---
title: "Code-y Bellinger"
author: "Willie Cohen, Ethan Samuels, Vaibhav Shah, Stefan Walzer-Goldfeld"
date: "May 13th, 2021"
output:
  rmdformats::readthedown:
    thumbnails: false
    highlight: NULL
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align="center")
library(tidyverse)
library(shiny)
library(ggplot2)
library(plotly)
library(baseballr)
library(plotly)
#library(GeomMLBStadiums)
load("data/savant_data_filtered.Rdata")
load("data/spatial_data.Rdata")
```

## Introduction

For more than one hundred years, baseball has been a numbers game. We currently have access to hundreds of thousands of statistics dating back to the 1800s, presenting the rare opportunity to compare a slugger like Babe Ruth (a pitcher and hitter during the roaring ‘20s) to Mike Trout (the best ball-player today). In 2015, however, the MLB introduced a new method to track statistics: Statcast.

What makes Statcast so exciting to baseball nerds is its novelty. For centuries, fans used the same statistics to compare players. Yet, all of these statistics were calculated based upon the final result of a given play. Statcast is unique as it tracks the movement of the game. With Statcast, we can examine a ball’s rotations per minute, launch angle and exit velocity, allowing us to calculate the exact position a ball landed on a field, or track ball flight paths like this:

![statcast animation](https://media4.giphy.com/media/LqOCx31NbvhieaBd8a/giphy.gif?cid=ecf05e47lowy5x99ftysj7jkpiex2et90sg3vww9k1to7076&rid=giphy.gif&ct=g)

More simply, Statcast helps us understand how a given event or outcome on the baseball field came to be instead of just observing what that event or outcome was. 


For this project, we wanted to analyze this Statcast data to provide insight on a number of decades-old baseball questions: Do certain players have a tendency to hit the ball to a certain location? If so, which players do so and where do they tend to hit the ball? Do “hitters-counts” really exist? That is, does a hitter really have better statistics when the count is in his favor? Can we generalize this information to all hitters? Do players hit better at home versus away? What pitches are most effective to certain hitters? 

The list of questions goes on, but our data wrangling must start somewhere. We hope the following interactive plots and games are both fun and insightful. Enjoy!

## Data Sources and Wrangling

The “baseballr” package contains functions that allow for easy scraping of MLB’s Statcast data, which is hosted on the website (https://baseballsavant.mlb.com/). Since the Statcast tool tracks statistics for every single pitch thrown, and there are upwards of 500,000 pitches thrown each season, we decided to only focus on the most recent full season for our analysis to make the data set more manageable. 

Since the package is made for professional use, the data was very specific about some categorical variables. For example, the “event” variable listed the normal “single”, “double”, “strike-out” events, but also some events like “sac_fly_double_play” and “field_error”, which we had to combine together to make the data more granular. 

While the data-set was huge vertically (716,497 rows, or pitches), it was large horizontally as well. Each pitch had 93 corresponding columns, including spin axis, location of the pitch’s release point, speed of the batter, location of the fielders, to name a few. There was also only a small subset of variables needed for each task we wanted to achieve, but for easier asynchronous collaboration, three datasets were created: spatial data for visualization, splits data between batting variables, and pitching/hitting data for our very own “Win the Pennant!” baseball game. Some datasets were also reformatted by pivoting columns to achieve the correct layout of data to easily make visualizations using default data formatting requirements in the ggplot library. 

   
```{r, include = FALSE}
#compiled data from baseballr
#  savant_data = data.frame()
#  for (month in 4:9) {
#   for (day in 1:31) {
#     if (day == 31 & month %in% c(4, 6, 9)) {
#        next
#     }
#     print(paste(day, month))
#     date <- paste("2019", str_pad(month, 2, pad = "0"), str_pad(day, 2, pad = "0"), sep = "-")
#     data <- scrape_statcast_savant(date, date)
#     savant_data <- rbind(savant_data, data)
#   }
# }
# 
# save(savant_data, file="data/savant_data.Rdata")
# 
# savant_data_filtered <- savant_data %>%
#   select(pitch_type, game_date, release_speed, release_pos_x, release_pos_y, player_name,
#          pitcher...8, events, zone, stand, p_throws, type, hit_location, balls, strikes, on_3b,
#          on_2b, on_1b, outs_when_up, inning, hc_x, hc_y, launch_speed, launch_angle, effective_speed,
#          estimated_ba_using_speedangle, estimated_woba_using_speedangle, pitch_number, pitch_name,
#          bat_score, fld_score, inning_topbot)
# 
# save(savant_data_filtered, file="data/savant_data_filtered.Rdata")
```


## Individual Player Spray Charts

Over the past decade in the MLB, there has been a drastic change in how teams approach defense. Traditionally, teams maintained the same or very similar defensive structure regardless of batter, seen below. The only major deviations resulting due to the situation, such as “infield-in” with a runner on third and less than two outs or “no doubles” which plays the outfielders further back and the corner infielders closer to the foul-line, most often in 1-run or tie games in the late innings or extras. However, with more advanced data available, teams began to alter their defensive styles not based on situation, but by the player that is at bat. After all, if a player hits 75 percent of their batted balls to right or left field, it makes sense to move fielders away from their traditional positions towards these relative “hot zones”. Thus, the shift was born.

Below is a diagram of a traditional defense versus a shift for a hitter that hits the ball to right field. Though there are numerous examples of different shifts, the one below is likely the first you would see in watching an MLB game today. But, in order to accurately design your shifts, you must first analyze where players hit the ball and at what frequency. In our analysis, we used spatial data combined with our statcast data to do just that. 

<center>
<a href="https://imgbb.com/"><img src="https://i.ibb.co/2s93Whb/Screen-Shot-2021-05-12-at-4-57-58-PM.png" alt="Screen-Shot-2021-05-12-at-4-57-58-PM" border="0"></a><br />
<\center>

<center>
<a href="https://ibb.co/HYbhZJV"><img src="https://i.ibb.co/K7fKn1X/Screen-Shot-2021-05-12-at-4-58-07-PM.png" alt="Screen-Shot-2021-05-12-at-4-58-07-PM" border="0"></a><br /> 
<\center>


Using the “GeomMLBStadiums” package, which contains stadium outlines positioned based upon Statcast’s xy-coordinate system for batted balls, we were able to use some simple trigonometry to divide a generic baseball field into five sections. 

```{r, include = FALSE}
#Shiny app code
#the wrangling below finds the angle of each point relative to the left edge of the field and then
#splits them into 5 zones of equal size (all 18 degrees wide)
# spatial_data <- spatial_data %>%
#   mutate(angle = ifelse(hc_x < 125, 
#                         atan((208 - hc_y) / (125 - hc_x)) * 180 / pi - 45, 
#                         135 - atan((208 - hc_y) / (hc_x - 125)) * 180 / pi)) %>%
#   mutate(zone = case_when((angle < 18) ~ "1",
#                           (18<angle & angle<36) ~ "2", 
#                           (36<angle & angle <54) ~ "3",
#                           (54<angle & angle <72) ~ "4",
#                           (72<angle & angle <90) ~ "5")) %>%
#   mutate(hit_out  = case_when(str_detect(events,"out") ~ "Out/Sac",
#                                       str_detect(events,"error") ~ "Out/Sac",
#                                       str_detect(events,"play") ~ "Out/Sac",
#                                       str_detect(events,"out") ~ "Out/Sac",
#                                       str_detect(events,"run") ~ "Hit",
#                                       str_detect(events,"single") ~ "Hit",
#                                       str_detect(events,"triple") ~ "Hit",
#                                       str_detect(events,"double") ~ "Hit",
#                                       str_detect(events,"fly") ~ "Out/Sac")) %>%
#   mutate(events = case_when(str_detect(events,"out") ~ "Out",
#                             str_detect(events,"error") ~ "Error",
#                             str_detect(events,"play") ~ "Out",
#                             str_detect(events,"out") ~ "Out",
#                             str_detect(events,"run") ~ "HR",
#                             str_detect(events,"single") ~ "1B",
#                             str_detect(events,"triple") ~ "3B",
#                             str_detect(events,"double") ~ "2B",
#                             str_detect(events,"fly") ~ "Sacrifice"))%>%
#   filter(!is.na(events))
# 
# 
# #create the outline for our field so we can make choropleth map 
# spatialPts <- data.frame(x = c("125", "30", "48",
#                                "125", "48", "90", 
#                                "125", "90", "160",
#                                "125", "160", "203",
#                                "125", "203", "220"),
#                             y = c("208", "100", "60", 
#                                   "208", "60", "20",
#                                   "208", "20", "20",
#                                   "208", "20", "60",
#                                   "208", "60", "100"),
#                             zone = c("1", "1", "1", 
#                                      "2", "2", "2", 
#                                      "3", "3", "3", 
#                                      "4", "4", "4",
#                                      "5", "5", "5"))
# 
# spatialPts <- spatialPts %>%
#   mutate(x = as.numeric(x), y = as.numeric(y))
# 
# 
# playerChoices <- unique(spatial_data$player_name)
# hitOutChoices <- unique(spatial_data$hit_out)
# hitChoices <- unique(spatial_data$events)
# 
# ui <- fluidPage(
#   
#  titlePanel("Player Spray Charts"),
#  sidebarLayout(
#    sidebarPanel(
#      selectizeInput(inputId  = "player",
#                  label = "Choose Player to View",
#                  choices = playerChoices,
#                  selected = "Altuve, Jose"),
#      checkboxGroupInput(inputId = "hitLocations",
#                    label = "Include Outcome(s)",
#                    choices = hitOutChoices,
#                    selected = "Hit",
#                    inline = TRUE)),
#    mainPanel(
#      plotOutput(outputId = "spray")
#    )
#  )
#   
# )
# 
# 
# server <- function(input, output) {
#   
#   output$spray <- renderPlot({
#   
#     #calculate the proportion hit to each zone based on what player is chosen
#   dataSpatial <- spatial_data %>%
#     filter(player_name %in% input$player) %>%
#     group_by(zone) %>%
#     summarize(zoneNum = n()) %>%
#     distinct() %>%
#     group_by(zone) %>%
#     summarize(zoneNum = zoneNum, zoneTot = sum(zoneNum)) %>%
#     mutate(zone = as.factor(zone), zoneProp = 100*zoneTot/sum(zoneTot)) %>%
#     right_join(spatialPts)
#   
#   dataSpray <- spatial_data %>%
#     filter(player_name %in% input$player) %>%
#     filter(hit_out %in% input$hitLocations)
#   
#   plot <- ggplot(dataSpatial) +
#     geom_polygon(aes(x = x, y = y, group = zone
#                      , fill = zoneProp), color = "black") +
#     theme_void() +
#     coord_fixed(ratio = 1.3) +
#     scale_y_reverse() +
#     geom_point(data = dataSpray, aes(x = hc_x, y=hc_y, color = events)) +
#     scale_fill_distiller(palette = "Greens", trans = "reverse") +
#     labs(fill = "Percentage of Batted Balls", color = "Outcome")
#     
#   plot
#     
#   
# 
#   })
# }
#  
# shinyApp(ui = ui, server = server)
# 
# 
```




``` {r}
#this test plot was created in order to find the intersections of our lines with the outlines of the stadium
#this was done in order to construct our spatial data set (titlds "spatialPts" in the above code")
# test_Spatial <- spatial_data %>%
#   filter(player_name == "Judge, Aaron" | player_name == "Trout, Mike") 
# 
# g <- ggplot(data = test_Spatial, aes(x = hc_x, y = hc_y, color = zone)) +
#     geom_point() +
#     geom_mlb_stadium(stadium_ids = "generic", stadium_segments = "all") +
#     scale_y_reverse() +
#     geom_segment(aes(x = 125, y = 208, xend = 48, yend = 208 - tan(63*pi/180)*77)) +
#     geom_segment(aes(x = 125, y = 208, xend = 95, yend =  208 - tan(81*pi/180)*30)) +
#     geom_segment(aes(x = 125, y = 208, xend = 155, yend = 208 + tan(99*pi/180)*30)) +
#     geom_segment(aes(x = 125, y = 208, xend = 202, yend = 208 + tan(117*pi/180)*77)) 
# 
# g
```


Then, using these divisions and their intersections with our generic baseball field, we were able to construct a data frame with coordinates associated with each of our five zones, for use in a spatial data plot. The shiny app below allows you to select any batter from the 2019 season and view their own individual spray chart, which plots the frequency at which that batter hit balls into each of our five designated zones. In relation to our discussion of the shift, I’d ask one to consider three spray charts of Jose Altuve, Joey Gallo, and Tim Anderson. 

Note that the map of the field is a generic field and the hitting statistics come from a wide range of fields which is why we see some balls that appear to be over the fence which are not home runs. Also, Statcast tracks location for non-home runs by where the first fielder makes contact with the ball which is why some balls that appear to be foul are hits. 

<iframe height="500" width="100%" frameborder="no" src="https://willie-cohen.shinyapps.io/spraycharts/"> </iframe>`


Altuve’s chart is one of a right handed pull hitter, who bats most of his balls to the left side of the field. In order to shift against Altuve, a team would take almost the opposite position of our example above, positioning the third baseman on the left field line, and the second baseman to the left of second base. Conversely, Joey Gallo hits an even larger proportion to the right side of the field and so a team would be likely to take a shift similar to the one above when he is hitting. Between the two extremes is Tim Anderson, whose hit frequency is similar across both sides of the field. Given this, a traditional, straight-up defense would be better suited to defend when he is at the plate. 

Spray charts of this type are not just a visualization, but a tool currently being used across the majors that impacts the game we see on the field. Of course, the analysis conducted by Major League teams spans far past simply examining the spray chart for players from a singular season. In order to understand further how teams plan their defensive positions using Statcast statistics, metrics such as launch angle, average exit velocity, or more predicative statistics such as expected batting average would be the next steps in analysis. It is also difficult to generalize players' tendencies off of one year of data, as many factors including injuries or a team change can drastically alter the course of a player's season. This does not mean that more recent statistics are not important in understanding how to game plan against a certain player at the plate, rather that all results should be contextualized with experiences outside the batter's box. 

## Splits Comparisons

Most compelling baseball questions follow an almost identical syntactic form: Does player X do better or worse when Y? In baseball vernacular, this is an inquiry into splits. 

We compared a hitter’s batting average and slugging percentage based on splits that we decided were some of the most interesting:
- Home versus away
- Count (3-1, 0-2, etc.)
- Pitcher’s throwing hand (lefty vs. righty)
- Runners on base (if so, how many)
- Pitch type (fastball, curveball, etc.)

Because our data set contained rows of every pitch thrown in 2019, without general at-bat by at-bat data, it took a fair share of nifty wrangling to calculate batting average and slugging percentage based on these splits. Here’s how we did it:


Our shiny app provides the user with interactivity to choose any batter from the 2019 season and see how their batting average and slugging percentage change based on any of the selected inputs.

<iframe height="500" width="100%" frameborder="no" src="https://esamuels.shinyapps.io/SplitsPlot/"> </iframe>`

As you can see, many of these splits do provide meaningful insight. For example, “hitters counts” do really exist. Almost all hitters are significantly better in high-ball/low-strike counts than they are in low-ball/high-strike counts. The reason why is fairly intuitive: when there are many balls and few strikes, pitchers have more pressure to throw pitches they can control into the strike zone, giving hitters not only a clue as to what pitch may come, but the freedom to lay-off the pitch if it’s not perfect. Additionally, with a bit of work we can see that righty hitters generally fare better against lefty pitchers and lefty hitters are more successful against righty pitchers. 

The stories that come out of the splits plot are endless, including Macro-trends that can be discovered by comparing the data of multiple players, as well as micro-trends that are specific to certain players (Mike Trout, for example, is extremely good at hitting sliders but relatively unsuccessful when it comes to hitting changeups).



## Game Simulator

In what is certainly the most unorthodox component of our project, we built a game that -- using statcast data -- allows a user to face off against MLB hitters. The goal: can you retire the side, save the game, and win the pennant?

To start an at-bat, you get to decide the throwing arm of the hitter as well as the hitting side of the batter. Once you do so, you are locked into the at-bat. From then on out, you must decide what pitches to use to get the hitter out. Our game sifts through all the inputs (pitcher-side, hitter-side, and count) and pulls a real pitch that occurred in the 2019 season at random that accommodates all of the inputs. 

So let’s say you find yourself in a 3-1 count. You must decide what the best pitch to throw is. If you go with off-speed, the simulator is more likely to choose an event in which the pitcher throws a 3-1 ball, walking the hitter. But if you throw a fastball, the simulator is more likely to select an event in which the pitcher found the strike-zone and the batter racked up a hit. In other words, because this pulls real events that correspond to the game’s inputs, you must deal with the same problems that catchers do when they are deciding what pitch to throw. 

Good luck!



<iframe height="1000" width="100%" frameborder="no" src="https://stefanwg.shinyapps.io/BaseballGame/"> </iframe>`



## Conclusion

Baseball is a sport that involves significant amounts of luck. You could hit the ball really hard, but if it’s right at a fielder, then you don’t get credit for doing almost everything right. Even over the course of an entire season, some players can be incredibly lucky. One way to extend this analysis would be to use more seasons to get a larger sample size. This would especially help for the splits visualizations, where players might only reach a 3-2 count a handful of times over the course of  a single season. The statistics we are looking at, like average, slugging percentage, and the type of hit, are also very simple statistics. Since Statcast was introduced in 2015, the vast array of new data has been used to develop much better statistics to measure player’s skill (barrels, xWOBA, and Hard Hit %, to name a few). To truly answer our questions, we would be better off diving into the more advanced statistics, which are both more descriptive of a player’s skill and more predictive of a player’s future success.

